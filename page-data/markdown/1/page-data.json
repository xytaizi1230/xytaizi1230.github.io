{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/markdown/1/","result":{"data":{"markdownRemark":{"html":"<p>正则表达式很强大，用来检测文本内容是否符合预期时非常好用。但是，错误的使用和不当的设计会出现很严重的性能问题。</p>\n<p>以下是一些常见的问题和解决方案：</p>\n<ol>\n<li><strong>性能问题</strong>：正则的性能会受到文本长度和模式复杂度的影响。\n如果正则表达式的模式过于复杂或包含大量的回溯操作，可能会导致性能下降。\n为了提高性能，可以使用更高效的算法和数据结构，或者优化正则表达式的模式。</li>\n<li><strong>可读性问题</strong>：过于复杂的正则会变得难以理解和维护。\n为了提高可读性，可以使用更易读的语法和结构，例如使用命名捕获组、注释和换行符。</li>\n<li><strong>错误问题</strong>：为了避免错误，可以使用测试工具和调试工具来验证正则表达式的正确性，并在编写和修改正则表达式时进行测试。</li>\n</ol>\n<h2>一个简单的例子</h2>\n<p>实际应用场景中，我们可能遇到一些需要匹配多个 <code>id</code> 的情况，例如：</p>\n<p>产品要我们验证表单中输入的 <code>id</code> 是否合法，<code>id</code> 的格式为纯数字组成，一次最多输入 <code>10</code> 个，使用逗号分割，有些用户可能会使用中文逗号或者空格来分割，需要兼容</p>\n<p>程序员略微思考后给出以下正则\n<code>/^([0-9]+(,|，|\\s)?){1,9}([0-9]+)?$/</code>\n这个正则看起来可以匹配 10 个 <code>id</code>，前九个中间可以用逗号、空格、中文逗号分隔，最后一个 <code>id</code> 可以省略。\n很棒是不是</p>\n<p>我们试下匹配</p>\n<pre><code class=\"language-js\">const dd = /^([0-9]+(,|，|\\s)?){1,9}([0-9]+)?$/\nundefined\ndd.test(\"1,2,3,4,5,6,7,8,9\")\ntrue\ndd.test(\"1,2,3,4,5,6,7,8,9,10\")\ntrue\ndd.test(\"1,2,3,4,5,6,7,8,9,10,11\")\nfalse\n</code></pre>\n<p>看起来完全能用对不对？毕竟测试的输出完全符合预期，我们开心的提测了</p>\n<p>没多久 QA 就找过来了，说你这个有性能问题啊，我输了几个 <code>id</code> 后页面就卡死了</p>\n<p>你说：“啊？我都试过了，没问题啊！“</p>\n<p>眼见为实，我们复现下 QA 的输入：</p>\n<pre><code class=\"language-js\">1044066897480127741 3522376740885022287 1044066897480127741 3522376740885022287 1044066897480127741 3522376740885022287 1044066897480127741 3522376740885022287 1044066897480127741 3522376740885022287 3522376740885022287\n</code></pre>\n<p><code>11</code> 个 <code>id</code>，按理说应该没什么毛病的，肯定会输出 <code>false</code> 才对</p>\n<p>我们在控制台看下输出</p>\n<pre><code class=\"language-js\">dd.test(\n  `7410668910447480127 7408835223502228776 7408820305218538790 7408820055087058226 7408820247030926629 7408820229343563017 7408820205817761051 7408820188390444314 7408818106883230995 7408818052759948598 7408818035575835940 7408818017217334569`\n)\n</code></pre>\n<p>嗯？我输出呢，怎么没反应了？？说好的 <code>false</code> 呢？</p>\n<p>等了 <code>20-30s</code> 后，你终于在控制台看到了输出，的确是没过验证，但是怎么会这么慢的？</p>\n<h2>盲生，你发现了华点</h2>\n<h3>正则表达式是如何运行的呢？</h3>\n<p>一般分为两种：<code>DFA</code> 和 <code>NFA</code></p>\n<ol>\n<li><code>DFA</code> 是确定性有限自动机，它的状态转移图是确定的，每个状态只有一个转移边。</li>\n<li><code>NFA</code> 是非确定性有限自动机，它的状态转移图是非确定的，每个状态可以有多个转移边。</li>\n</ol>\n<p>正则表达式的匹配过程是基于 <code>NFA</code> 的，<code>NFA</code> 的状态转移图是根据正则表达式的模式动态生成的。</p>\n<p>我们的程序就是按照 <code>NFA</code> 的方式来匹配的，所以我们的正则表达式的模式越复杂，<code>NFA</code> 的状态转移图就会越复杂，也就越容易出现性能问题。</p>\n<p>它要不断的从字符串中寻找匹配的字符，如果存在分支，就依次进行分支的遍历匹配，遇见不匹配的则进行回退，开始新一轮分支的匹配。</p>\n<p>那么这段正则的问题就很明显了</p>\n<p><code>^([0-9]+(,|，|\\s)?){1,9}</code> 这一部分是有限内容匹配，它的状态转移图是确定的，每个状态只有一个转移边。</p>\n<p>而最后的<code>([0-9]+)?$</code> 这一部分是不确定内容匹配，它的状态转移图是非确定的，每个状态可以有多个转移边。</p>\n<p>我们有每次匹配都是带上前面的 <code>9</code> 次匹配，同时一个字符一个字符的去匹配后续内容</p>\n<p>话不多说，直接上结论</p>\n<p>(regex101.com)[<a href=\"https://regex101.com/\">https://regex101.com/</a>]\n这是一个可以查看正则表达是性能的网站</p>\n<p>打开这个网站，我们输入我们的正则表达式，和需要匹配的内容，就能查看结果了</p>\n<p>如果遇到了灾难回溯，它会自动停止执行，然后告诉你原因</p>\n<p>我们这个正则，匹配上述文本需要进行\n<code>Match 1 halted after 160 201 step(s)</code></p>\n<h2>如何优化</h2>\n<ol>\n<li>避免可选分组的回溯</li>\n</ol>\n<p>使用非捕获分组和明确的匹配方式。\n可以将 <code>(,|，|\\s)?</code> 替换为 <code>[,，\\s]?</code>，减少分支数量。</p>\n<ol start=\"2\">\n<li>合并重复逻辑，减少回溯的可能性</li>\n</ol>\n<p>把重复的模式合并成一个更紧凑的表达式。</p>\n<pre><code class=\"language-js\">^[0-9]+([,，\\s][0-9]+){0,9}$\n</code></pre>\n<ul>\n<li><code>^[0-9]+</code> 开头匹配至少一位数字。</li>\n<li><code>([,，\\s][0-9]+){0,9}</code> 后续匹配最多 <code>9</code> 次（总共 <code>10</code> 组）的分隔符（<code>,、，、空格</code>）和数字组合。</li>\n<li>消除末尾的 <code>([0-9]+)?</code> 已在前面涵盖了所有可能的组合。</li>\n</ul>\n<h2>优化后的结果</h2>\n<pre><code class=\"language-js\">const dd = /^[0-9]+([,，\\s][0-9]+){0,9}$/;\n\ndd.test(`7410668910447480127 7408835223502228776 7408820305218538790 7408820055087058226 7408820247030926629 7408820229343563017 7408820205817761051 7408820188390444314 7408818106883230995 7408818052759948598 7408818035575835940 7408818017217334569`);\n\n// dd: 0.14794921875 ms\n\nfalse\n</code></pre>\n<h2>写在最后</h2>\n<p>正则的使用还是需要慎重，一般来说，我们应该只在可控的场景下使用正则。\n比如输入内容的长度，格式都是可控，只使用正则作为校验或者提取内容的手段</p>\n<p>对于不可控的场景，建议先逐步缩短需要匹配内容的长度，再进行正则匹配。</p>\n<p>另外如果可能，最好使用^和$来限制匹配的范围，避免不必要的回溯。</p>","frontmatter":{"title":"小心使用正则","date":"2025-01-08 11:17:57"}}},"pageContext":{"slug":"/markdown/1/","previous":{"title":"最好用不到的开发知识","slug":"/markdown/2/"}}},"staticQueryHashes":["3649515864","63159454"],"slicesMap":{}}