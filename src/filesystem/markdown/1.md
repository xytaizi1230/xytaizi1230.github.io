---
title: "小心使用正则"
date: "2025-01-08 11:17:57"
desc: "正则很好用，但是未经充分测试的正则很容易出现问题"
---

正则表达式很强大，用来检测文本内容是否符合预期时非常好用。但是，错误的使用和不当的设计会出现很严重的性能问题。

以下是一些常见的问题和解决方案：

1. **性能问题**：正则的性能会受到文本长度和模式复杂度的影响。
   如果正则表达式的模式过于复杂或包含大量的回溯操作，可能会导致性能下降。
   为了提高性能，可以使用更高效的算法和数据结构，或者优化正则表达式的模式。
2. **可读性问题**：过于复杂的正则会变得难以理解和维护。
   为了提高可读性，可以使用更易读的语法和结构，例如使用命名捕获组、注释和换行符。
3. **错误问题**：为了避免错误，可以使用测试工具和调试工具来验证正则表达式的正确性，并在编写和修改正则表达式时进行测试。

## 一个简单的例子

实际应用场景中，我们可能遇到一些需要匹配多个 `id` 的情况，例如：

产品要我们验证表单中输入的 `id` 是否合法，`id` 的格式为纯数字组成，一次最多输入 `10` 个，使用逗号分割，有些用户可能会使用中文逗号或者空格来分割，需要兼容

程序员略微思考后给出以下正则
`/^([0-9]+(,|，|\s)?){1,9}([0-9]+)?$/`
这个正则看起来可以匹配 10 个 `id`，前九个中间可以用逗号、空格、中文逗号分隔，最后一个 `id` 可以省略。
很棒是不是

我们试下匹配

```js
const dd = /^([0-9]+(,|，|\s)?){1,9}([0-9]+)?$/
undefined
dd.test("1,2,3,4,5,6,7,8,9")
true
dd.test("1,2,3,4,5,6,7,8,9,10")
true
dd.test("1,2,3,4,5,6,7,8,9,10,11")
false
```

看起来完全能用对不对？毕竟测试的输出完全符合预期，我们开心的提测了

没多久 QA 就找过来了，说你这个有性能问题啊，我输了几个 `id` 后页面就卡死了

你说：“啊？我都试过了，没问题啊！“

眼见为实，我们复现下 QA 的输入：

```js
1044066897480127741 3522376740885022287 1044066897480127741 3522376740885022287 1044066897480127741 3522376740885022287 1044066897480127741 3522376740885022287 1044066897480127741 3522376740885022287 3522376740885022287
```

`11` 个 `id`，按理说应该没什么毛病的，肯定会输出 `false` 才对

我们在控制台看下输出

```js
dd.test(
  `7410668910447480127 7408835223502228776 7408820305218538790 7408820055087058226 7408820247030926629 7408820229343563017 7408820205817761051 7408820188390444314 7408818106883230995 7408818052759948598 7408818035575835940 7408818017217334569`
)
```

嗯？我输出呢，怎么没反应了？？说好的 `false` 呢？

等了 `20-30s` 后，你终于在控制台看到了输出，的确是没过验证，但是怎么会这么慢的？

## 盲生，你发现了华点

### 正则表达式是如何运行的呢？

一般分为两种：`DFA` 和 `NFA`

1. `DFA` 是确定性有限自动机，它的状态转移图是确定的，每个状态只有一个转移边。
2. `NFA` 是非确定性有限自动机，它的状态转移图是非确定的，每个状态可以有多个转移边。

正则表达式的匹配过程是基于 `NFA` 的，`NFA` 的状态转移图是根据正则表达式的模式动态生成的。

我们的程序就是按照 `NFA` 的方式来匹配的，所以我们的正则表达式的模式越复杂，`NFA` 的状态转移图就会越复杂，也就越容易出现性能问题。

它要不断的从字符串中寻找匹配的字符，如果存在分支，就依次进行分支的遍历匹配，遇见不匹配的则进行回退，开始新一轮分支的匹配。

那么这段正则的问题就很明显了

`^([0-9]+(,|，|\s)?){1,9}` 这一部分是有限内容匹配，它的状态转移图是确定的，每个状态只有一个转移边。

而最后的`([0-9]+)?$` 这一部分是不确定内容匹配，它的状态转移图是非确定的，每个状态可以有多个转移边。

我们有每次匹配都是带上前面的 `9` 次匹配，同时一个字符一个字符的去匹配后续内容

话不多说，直接上结论

(regex101.com)[https://regex101.com/]
这是一个可以查看正则表达是性能的网站

打开这个网站，我们输入我们的正则表达式，和需要匹配的内容，就能查看结果了

如果遇到了灾难回溯，它会自动停止执行，然后告诉你原因

我们这个正则，匹配上述文本需要进行
`Match 1 halted after 160 201 step(s)`

## 如何优化

1. 避免可选分组的回溯

使用非捕获分组和明确的匹配方式。
可以将 `(,|，|\s)?` 替换为 `[,，\s]?`，减少分支数量。

2. 合并重复逻辑，减少回溯的可能性

把重复的模式合并成一个更紧凑的表达式。

```js
^[0-9]+([,，\s][0-9]+){0,9}$
```

- `^[0-9]+` 开头匹配至少一位数字。
- `([,，\s][0-9]+){0,9}` 后续匹配最多 `9` 次（总共 `10` 组）的分隔符（`,、，、空格`）和数字组合。
- 消除末尾的 `([0-9]+)?` 已在前面涵盖了所有可能的组合。

## 优化后的结果

```js
const dd = /^[0-9]+([,，\s][0-9]+){0,9}$/;

dd.test(`7410668910447480127 7408835223502228776 7408820305218538790 7408820055087058226 7408820247030926629 7408820229343563017 7408820205817761051 7408820188390444314 7408818106883230995 7408818052759948598 7408818035575835940 7408818017217334569`);

// dd: 0.14794921875 ms

false
```

## 写在最后

正则的使用还是需要慎重，一般来说，我们应该只在可控的场景下使用正则。
比如输入内容的长度，格式都是可控，只使用正则作为校验或者提取内容的手段

对于不可控的场景，建议先逐步缩短需要匹配内容的长度，再进行正则匹配。

另外如果可能，最好使用^和$来限制匹配的范围，避免不必要的回溯。
